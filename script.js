

const arr = [10, 2, 30, 4];

// let ans = arr.map((e) => {
//     return e > 2;
// });
// console.log(ans);

// let filterAns = arr.filter((e) => {
//     return e > 2;
// });
// console.log(filterAns);

// arr.sort((a, b) => {
//     return a - b;
// });
// console.log(arr);
// arr.shift(); // removes the first element from the array
// arr.unshift(5) // insert element at the beginig of the array
// console.log(arr);

// const arr1 = ["color1", "color2", "color3", "color4"];
// const [a, b, ...c] = arr1;
// console.log(a);
// console.log(b);
// console.log(c);


// console.log(Myval);
// let Myval = 10;

// console.log("Start");
// setTimeout(() => {
//    console.log("Timeout");
// }, 0)
// console.log("End");

// setTimeout(() => {
//     console.log("Timeout");
    
// },0)
// Promise.resolve().then(() => console.log('Promise'));
// console.log("End");
//  End -> Promise -> Timeout
//  first the setimeout will go to the callback queue and then the Promise will go to the Microtask queue , the priority is given to the MIcro-task queue to be executed first then Callback queue will be empty later, thats why Promise is Printed nefore the Timeout

// console.log({}=={});

// const number = [0, 1, 2, 3, 4, 5];
// let ans = number.filter((e) => e < 3).map((val) => val+5);
// console.log(ans);
// console.log(number);

// const str = "hi im working right now";
// const array = str.split(' ');

// let upperCase = array.map((val) => {
//    return val[0].toUpperCase()+ val.slice(1)
// });
// console.log(upperCase);

